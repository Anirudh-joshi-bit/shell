#include "header.h"

// postfix is not NULL terminating instead "" terminating

int fds[2];
// oepn a file
// execute the program
// put output into the file
// read the file (filter it and remove all the /n)
// insert the content of that file (i.e a string) into the stack
// continue this process

// to open a file use "open()" syscall that returns the file descriptor of that opened file
// pipe the output os command into that file using "pipe()"

int input_redir_command (char* operand1, char* operand2){
	int size = 0;
	if (operand1 == NULL || operand2 == NULL){
		perror ("ERROR bad command and operations \n");
		return -1;
	}
	char** file_name = tokenise (operand2, " ", &size);
	if (size > 1){
		perror ("ERROR too many file names !! \n");
		clean2Dstring(file_name, 0, size-1);
		return -1;
	}

	int fd_file = open ( file_name[0], O_RDONLY);

	if (fd_file < 0){
		perror ("file does not exits \n");
		clean2Dstring(file_name, 0, size-1);
													 	// MAXLEN_COMMAND = size of
		return -1;										// 2d string returned by tokenise
	}
	int stdin_cp = dup(STDIN_FILENO);

	if (stdin_cp < 0){
		close (fd_file);
		perror ("error in dup STDIN_FILENO");

		return -1;
	}

	if (dup2 (fd_file, STDIN_FILENO) < 0) {
		perror ("error in dup2");
		close (fd_file);
		close (stdin_cp);
		return -1;
	}

	int f = fork ();

	if (f == 0) {				// child proces

		char** tokens = tokenise (operand1, " \n\t", &size);
		execvp (tokens[0], tokens);

		perror ("command not found !! \n");
		exit (-1);

	}
	else if (f > 0){

		int st;
		wait (&st);


		close (fd_file);
		if (dup2 (stdin_cp, STDIN_FILENO) < 0){
			perror ("error in parent dup2 in input redir command\n");
			return -1;
		}
		close (stdin_cp);
	}
	else {				// error in fork !!

		perror ("ERROR in fork in input redirection\n");
		if (dup2 (stdin_cp, STDIN_FILENO) < 0){
			perror ("ERROR in dup2\n");
			close (fd_file);
			return -1;
		}
		close (fd_file);
		return -1;
	}

	return 0;
}

int output_redir_command (char* operand1, char* operand2){
	printf ("this is output_redir_command \n");
	return 0;

}

int append_output_command (char* operand1, char* oprand2){
	printf ("this is append_output_command\n");
	return 0;

}

int here_document_command (char* operand1, char* operand2){
	printf ("this is here_document_command\n");
	return 0;

}

int pipe_command (char* operand1, char* operand2){
	printf ("this is pipe_command\n");
	return 0;

}

int background_exe_command (char* operand1, char* operand2){
	printf ("this is background_exe_command\n");
	return 0;

}


char* launch_command (char* operator, char* operand1, char* operand2){

	printf ("inside the launch command \n");
	// we can use multiple pipes to a single fds[2]   no worries
	pipe(fds);


	// dup will open the file present in STDOUT_FILENO in a different fd
	// that fd is stdout_cp
	int stdout_cpy = dup(STDOUT_FILENO);
	if (stdout_cpy < 0){
		perror ("ERROR in stdout_cpy in launch command \n");
		close (fds[0]);
		close (fds[1]);
		return NULL;
	}
	// set the stdout to fd 1 so that output can be read
	// child will copy the fds meaning if fds[0] is opened in fd 0 as parent child will also open fds[0] in fd 0
	if (dup2 (fds[1], STDOUT_FILENO )< 0){
		perror ("ERROR in dup2 fd[1] in launch command \n");
		close (fds[0]);
		close (fds[1]);
		close (stdout_cpy);
		return NULL;
	}

	char* output = malloc (MAXLEN_OUTPUT);
	if (!strcmp (operator, "<")) {
		if (input_redir_command(operand1, operand2)){
			perror ("ERROR in input redir\n");
			close (fds[1]);
			close (fds[0]);
			dup2 (stdout_cpy, STDOUT_FILENO);
			close (stdout_cpy);
			return NULL;
		}
	}
	if (!strcmp (operator, ">")){

		output_redir_command(operand1, operand2);
	}
	if (!strcmp (operator, ">>")) {

		append_output_command(operand1, operand2);
	}
	if (!strcmp (operator, "<<")) {

		here_document_command(operand1, operand2);
	}
	if (!strcmp (operator, "|")) {

		pipe_command(operand1, operand2);
	}
	if (!strcmp (operator, "&")) {

		background_exe_command(operand1, operand2);
	}
	if (read (fds[0], output, MAXLEN_OUTPUT) < 0){
		perror ("ERROR in read in launch command \n");
		close (fds[0]);
		close (fds[1]);
		dup2 (stdout_cpy, STDOUT_FILENO);
		close (stdout_cpy);
		return NULL;
	}

	close (fds[0]);
	close (fds[1]);

	if (dup2 (stdout_cpy, STDOUT_FILENO) < 0){			// this will reopen the default stdout
		perror ("ERROR in dup2 stdout_cpy\n");
		exit (1);
	}

	if (close (stdout_cpy) < 0){
		perror ("ERROR in close (stdout_cpy) in launch command \n");
		return	NULL;
	}

		printf ("this is after restoring the stdout \n");
	return output ;
}

/*
 *	<
 *		input redirection3
 *		redirects file into a program stdinput
 *
 *	>
 *		output rediretction
 *		reditect the output of a program to a file
 *
 *	>>
 *		append output
 *		append the output to a file
 *
 *	<<
 *		here document
 *		everyt thing until the delim is passed as stdin to the command
 *
 *	|
 *		pipe
 *		passes the output of a command as input of another command
 *
 *	&
 *		background exe
 *		exe in the background
 *
 */

int execute (char** postfix){

	stack_t_ st;
	stack_init (&st);

	char** post_iter = postfix;

	while (strcmp ("", *post_iter)) {
		if (isOper (*post_iter)){
			char *operand1 = NULL, *operand2 =	NULL;

			if (st.size)
				operand2 = stack_top (&st);
			if (operand2){
				stack_pop(&st);
				if (st.size){
					operand1 = stack_top(&st);
					stack_pop(&st);
				}
				char* output = launch_command (*post_iter, operand1, operand2);
				printf ("hii %s\n is the output\n", output);
				if (output)  stack_push(&st, output);
			}
			else {
				perror ("ERROR      operand2 is null\n");
				return 1;
			}
		}
		else {
			stack_push (&st, *post_iter);
		}
		post_iter ++;

	}

	if (st.size > 1){
		perror ("ERROR.... bad command !\n");
		return -1;
	}

	if (st.size == 0) {
		printf ("after the execution, size of stack is 0 !! which is not desired\n");
		return -1;
	}
	//printf ("%s\n this is the output ... \n", stack_top (&st));

	return 0;

}
